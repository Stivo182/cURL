// @strict-types

#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

#Область ОписаниеПеременных

Перем ПутьКИсполняемомуФайлу; // Строка
Перем НаборШифров; // Массив из Строка
Перем ЗаголовкиЗапроса; // Соответствие из КлючИЗначение
Перем ЗаголовкиОтвета; // Соответствие из КлючИЗначение
Перем КодСостояния; // Число
Перем РежимЭмуляцииБраузера; // Булево
Перем ИнтернетПрокси; // ИнтернетПрокси, Неопределено
Перем ИмяПользователяНаСервере; // Строка
Перем ПарольПользователяНаСервере; // Строка
Перем СпособАутентификацииНаСервере; // Строка
Перем ПеренаправлятьЗапросПоНовомуURI; // Булево
Перем ВыполнятьАутентификациюПриПеренаправленииНаДругойХост; // Булево
Перем ОбновлятьКуки; // Булево
Перем ПутьКРезультату; // Строка
Перем ПутьКЗаголовкамОтвета; // Строка
Перем ПутьКЗаголовкамЗапроса; // Строка
Перем ПутьКТелуЗапроса; // Строка
Перем ВременныеФайлы; // Соответствие из КлючИЗначение
Перем ИменаЗаголовковЗапросаВНижнемРегистре; // Соответствие из КлючИЗначение

#КонецОбласти

#Область ПрограммныйИнтерфейс

// Выполняет POST запрос.
// 
// Параметры:
//  URL - Строка - URL
//  Тело - Строка - Простой текст, Адрес двоичных данных во временном хранилище 
//       - Структура
//       - Соответствие из КлючИЗначение
//       - ДвоичныеДанные
//       - Файл
//       - Неопределено
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция Post(URL, Тело = Неопределено) Экспорт
	Возврат ОтправитьЗапрос(URL, "POST", Тело);
КонецФункции

// Выполняет GET запрос и возвращает ответ в текстовом формте.
// 
// Параметры:
//  URL - Строка - URL
// 
// Возвращаемое значение:
//  Строка - Ответ в текстовом формте
Функция GetString(URL) Экспорт
	Возврат Get(URL).ОтветКакТекст();
КонецФункции

// Выполняет GET запрос и возвращает ответ в формате JSON.
// 
// Параметры:
//  URL - Строка - URL
// 
// Возвращаемое значение:
//  Произвольный - Ответ в формате JSON
Функция GetJson(URL) Экспорт
	Возврат Get(URL).ОтветКакJson();
КонецФункции

// Выполняет GET запрос и возвращает ответ в формате двоичных данных.
// 
// Параметры:
//  URL - Строка - URL
// 
// Возвращаемое значение:
//  ДвоичныеДанные, Неопределено - Ответ запроса в формате двоичных данных
Функция GetBinaryData(URL) Экспорт
	Возврат Get(URL).ОтветКакДвоичныеДанные();
КонецФункции

// Выполняет GET запрос.
// 
// Параметры:
//  URL - Строка - URL
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция Get(URL) Экспорт
	Возврат ОтправитьЗапрос(URL, "GET");
КонецФункции

// Возвращает путь к файлу результата запроса.
// 
// Возвращаемое значение:
//  Строка, Неопределено - Путь к файлу результата запроса
Функция ОтветКакПутьФайлу() Экспорт
	
	Если Не ЗначениеЗаполнено(ПутьКРезультату) Тогда
		Возврат Неопределено;
	КонецЕсли;
		
	Файл = Новый Файл(ПутьКРезультату);
	Если Файл.Существует() Тогда
		Возврат ПутьКРезультату;
	КонецЕсли;
	
КонецФункции

// Возвращает ответ запроса в формате двоичных данных.
// 
// Параметры:
//  УдалитьИзДисковойПамяти - Булево - Удаляет артефакты из дисковой памяти
// 
// Возвращаемое значение:
//  ДвоичныеДанные, Неопределено - Ответ запроса в формате двоичных данных
Функция ОтветКакДвоичныеДанные(УдалитьИзДисковойПамяти = Истина) Экспорт
	
	ИмяФайла = ОтветКакПутьФайлу();
	
	Результат = Неопределено;
	Если Не ИмяФайла = Неопределено Тогда
		Результат = Новый ДвоичныеДанные(ИмяФайла);
	КонецЕсли;
	
	Если УдалитьИзДисковойПамяти Тогда
		УдалитьАртефакты();
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает ответ запроса в текстовом формате.
// 
// Параметры:
//  УдалитьИзДисковойПамяти - Булево - Удаляет артефакты из дисковой памяти
// 
// Возвращаемое значение:
//  Строка, Неопределено - Ответ запроса в текстовом формате
Функция ОтветКакТекст(УдалитьИзДисковойПамяти = Истина) Экспорт
	
	ИмяФайла = ОтветКакПутьФайлу();
	
	Результат = Неопределено;
	Если Не ИмяФайла = Неопределено Тогда
		ЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, КодировкаТекста.UTF8);
		Результат = ЧтениеТекста.Прочитать();
		ЧтениеТекста.Закрыть();	
	КонецЕсли;
	
	Если УдалитьИзДисковойПамяти Тогда
		УдалитьАртефакты();
	КонецЕсли;
		
	Возврат Результат;
	
КонецФункции

// Возвращает ответ запроса в формате JSON.
// 
// Параметры:
//  УдалитьИзДисковойПамяти - Булево - Удаляет артефакты из дисковой памяти
// 
// Возвращаемое значение:
//  Произвольный - Ответ запроса в формате JSON
Функция ОтветКакJson(УдалитьИзДисковойПамяти = Истина) Экспорт
		
	ИмяФайла = ОтветКакПутьФайлу();
	
	Результат = Неопределено;
	Если Не ИмяФайла = Неопределено Тогда
		Результат = ПрочитатьФайлJSON(ИмяФайла);
	КонецЕсли;
	
	Если УдалитьИзДисковойПамяти Тогда
		УдалитьАртефакты();
	КонецЕсли;
		
	Возврат Результат;
	
КонецФункции

// Устанавливает HTTP заголовки.
// 
// Параметры:
//  Заголовки - Соответствие из КлючИЗначение
//            - Строка - Строка содержащая пары ключ-значение. Значение от ключа должно быть разделено двоеточием. 
//                       Пары должны быть разделены символом переноса.
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция УстановитьЗаголовки(Заголовки) Экспорт
	Если ТипЗнч(Заголовки) = Тип("Соответствие") Тогда
		ЗаголовкиЗапроса = Заголовки;
	Иначе
		ЗаголовкиЗапроса = ЗаголовкиИзТекста(Заголовки);
	КонецЕсли;
	
	ОбновитьИменаЗаголовковВВерхнемРегистре();
	
	Возврат ЭтотОбъект();
КонецФункции

// Устанавливает HTTP заголовок.
// 
// Параметры:
//  Имя - Строка - Имя заголовка
//  Значение - Строка - Значение
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция УстановитьЗаголовок(Имя, Значение) Экспорт
	
	ИмяИсходное = ИменаЗаголовковЗапросаВНижнемРегистре.Получить(НРег(Имя)); // Строка
	Если ИмяИсходное = Неопределено Тогда
		ИмяИсходное = Имя;	
	КонецЕсли;
		
	ЗаголовкиЗапроса.Вставить(ИмяИсходное, Значение);	
	ИменаЗаголовковЗапросаВНижнемРегистре.Вставить(НРег(ИмяИсходное), ИмяИсходное);
	
	Возврат ЭтотОбъект();

КонецФункции

// Возвращает значение заголовка запроса.
// 
// Параметры:
//  Имя - Строка - Имя заголовка запроса
// 
// Возвращаемое значение:
//  Строка - Значение заголовка запроса
Функция Заголовок(Имя) Экспорт
	ИмяИсходное = ИменаЗаголовковЗапросаВНижнемРегистре.Получить(НРег(Имя)); // Строка
	
	Если ИмяИсходное = Неопределено Тогда
		Возврат "";	
	КонецЕсли;
	
	Значение = ЗаголовкиЗапроса.Получить(ИмяИсходное);
	Если Значение = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат Значение;	
КонецФункции

// Возвращает значение заголовка ответа.
// 
// Параметры:
//  Имя - Строка - Имя заголовка ответа
// 
// Возвращаемое значение:
//  Строка, Массив из Строка, Неопределено - Значение заголовка ответа
Функция ЗаголовокОтвета(Имя) Экспорт
	Возврат ЗаголовкиОтвета.Получить(НРег(Имя));	
КонецФункции

// Заголовки ответа.
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение - Заголовки ответа:
//  	* Ключ - Строка - Имя заголовка
//  	* Значение - Строка, Массив из Строка - Значение(я) заголовка
Функция ЗаголовкиОтвета() Экспорт
	//@skip-check invocation-parameter-type-intersect
	Возврат СкопироватьСоответствие(ЗаголовкиОтвета);
КонецФункции

// Возвращает куки.
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение - Куки
Функция Куки() Экспорт
	
	Куки = Новый Соответствие();
	Массив = СтрРазделить(КукиСтрокой(), ";"); // Массив из Строка
	
	Для Каждого КлючИЗначениеСтрока Из Массив Цикл
		
		ПозицияРавенства = СтрНайти(КлючИЗначениеСтрока, "=");
		
		Если ПозицияРавенства Тогда
			Имя = СокрЛП(Сред(КлючИЗначениеСтрока, 1, ПозицияРавенства - 1));
			Значение = СокрЛП(Сред(КлючИЗначениеСтрока, ПозицияРавенства + 1));
			Куки.Вставить(Имя, Значение);
		Иначе
			Куки.Вставить(КлючИЗначениеСтрока);
		КонецЕсли;
			
	КонецЦикла;
	
	Возврат Куки;
	
КонецФункции

// Возвращает куки строкой.
// 
// Возвращаемое значение:
//  Строка - Куки
Функция КукиСтрокой() Экспорт
	Возврат Заголовок("Cookie");
КонецФункции

// Устанавливает куки.
// 
// Параметры:
//  Куки - Строка - Куки
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция УстановитьКуки(Куки) Экспорт
	УстановитьЗаголовок("Cookie", Куки);
	Возврат ЭтотОбъект();	
КонецФункции

// Дополнять куки значениями Set-Cookie из заголовков ответа
// 
// Параметры:
//  Обновлять - Булево - Обновлять
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция ОбновлятьКуки(Обновлять = Истина) Экспорт
	ОбновлятьКуки = Обновлять;
	Возврат ЭтотОбъект();
КонецФункции

// Куки дополняются значениями Set-Cookie из заголовков ответа
Процедура ОбновитьКуки() Экспорт
	
	КукиСтрокой = Заголовок("Cookie");
	НовыеКукиСтрокой = КукиИзОтветаСтрокой();
		
	Если Не ПустаяСтрока(НовыеКукиСтрокой) Тогда
		КукиСтрокой = КукиСтрокой 
			+ ?(ПустаяСтрока(КукиСтрокой), "", "; ")
			+ НовыеКукиСтрокой;
	КонецЕсли;
	
	УстановитьЗаголовок("Cookie", КукиСтрокой);
	
КонецПроцедуры

// Возвращает куки полученые из заголовка ответа Set-Cookie.
// 
// Возвращаемое значение:
//  Массив из см. НоваяЗаписьКуки
Функция КукиИзОтвета() Экспорт
	
	Куки = Новый Массив; // Массив из см. НоваяЗаписьКуки

	СтрокиУстановкиКуки = ЗаголовокОтвета("Set-Cookie");
	
	Если ТипЗнч(СтрокиУстановкиКуки) = Тип("Массив") Тогда
		Для Каждого Строка Из СтрокиУстановкиКуки Цикл
			ЗаписьКуки = ДесериализоватьSetCookie(Строка);
			Если ЗаписьКуки <> Неопределено Тогда
				Куки.Добавить(ЗаписьКуки);	
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ТипЗнч(СтрокиУстановкиКуки) = Тип("Строка") Тогда
		ЗаписьКуки = ДесериализоватьSetCookie(СтрокиУстановкиКуки);
		Если ЗаписьКуки <> Неопределено Тогда
			Куки.Добавить(ЗаписьКуки);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Куки;
	
КонецФункции

// Возвращает куки полученые из заголовка ответа Set-Cookie строкой.
// 
// Возвращаемое значение:
//  Строка - Куки из ответа строкой
Функция КукиИзОтветаСтрокой() Экспорт
	
	КукиСтрокой = "";
	Для Каждого Запись Из КукиИзОтвета() Цикл
		КукиСтрокой = КукиСтрокой 
			+ СтрШаблон("%1%2=%3", 
				?(КукиСтрокой = "", "", "; "),
				Запись["Name"],
				Запись["Value"]);
	КонецЦикла;
	
	Возврат КукиСтрокой;
	
КонецФункции

// Аутентификация на сервере (Basic Authentication).
// 
// Параметры:
//  ИмяПользователя - Строка - Имя пользователя
//  Пароль - Строка - Пароль
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция АутентификацияНаСервере(ИмяПользователя, Пароль) Экспорт
	ИмяПользователяНаСервере = ИмяПользователя;
	ПарольПользователяНаСервере = Пароль;
	СпособАутентификацииНаСервере = СпособАутентификацииНаСервереBasic();
	Возврат ЭтотОбъект();
КонецФункции

// Аутентификация на сервере (Digest Authentication).
// 
// Параметры:
//  ИмяПользователя - Строка - Имя пользователя
//  Пароль - Строка - Пароль
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция АутентификацияНаСервереDigest(ИмяПользователя, Пароль) Экспорт
	ИмяПользователяНаСервере = ИмяПользователя;
	ПарольПользователяНаСервере = Пароль;
	СпособАутентификацииНаСервере = СпособАутентификацииНаСервереDigest();
	Возврат ЭтотОбъект();
КонецФункции

// Добавляет шифры в набор.
// 
// Параметры:
//  Шифры - Строка - Шифры
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция ДобавитьШифры(Шифры) Экспорт
	//@skip-check invocation-parameter-type-intersect
	ДополнитьМассив(НаборШифров, СтрРазделить(Шифры, ","), Истина);
	Возврат ЭтотОбъект();
КонецФункции

// Установить исполняемый файл.
// 
// Параметры:
//  Путь - Строка - Путь
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция УказатьИсполняемыйФайл(Путь) Экспорт
	ПутьКИсполняемомуФайлу = Путь;
	Возврат ЭтотОбъект();
КонецФункции

// Устанавливает прокси.
// 
// Параметры:
//  Прокси - ИнтернетПрокси, Неопределено - Прокси
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция УстановитьПрокси(Прокси) Экспорт
	ИнтернетПрокси = Прокси;
	Возврат ЭтотОбъект();
КонецФункции

// Перенаправит запрос по новому Location, если сервер вернул ответ с кодом состояния 3XX.
// 
// Параметры:
//  Перенаправлять - Булево - Перенаправлять
//  ВыполнятьАутентификациюНаДругомХосте - Булево - Выполнять аутентификацию при перенаправлении на другой хост
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция ПеренаправлятьЗапрос(Перенаправлять = Истина, ВыполнятьАутентификациюНаДругомХосте = Ложь) Экспорт
	ПеренаправлятьЗапросПоНовомуURI = Перенаправлять;
	ВыполнятьАутентификациюПриПеренаправленииНаДругойХост = ВыполнятьАутентификациюНаДругомХосте;
	Возврат ЭтотОбъект();
КонецФункции

// Эмуляция Сhrome.
// 
// Параметры:
//  Включить - Булево - Включить эмуляцию
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция ЭмуляцияБраузера(Включить = Истина) Экспорт
	РежимЭмуляцииБраузера = Включить;
	Возврат ЭтотОбъект();
КонецФункции

// Код состояния.
// 
// Возвращаемое значение:
//  Число - Код состояния
Функция КодСостояния() Экспорт
	Возврат КодСостояния;
КонецФункции

// Очищает артефакты запроса и восстанавливает исходные настройки.
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция Закрыть() Экспорт
	УдалитьАртефакты();
	УстановитьНачальныеНастройки();
	Возврат ЭтотОбъект();
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура УстановитьНачальныеНастройки()
	
	КодСостояния = 0;
	ИнтернетПрокси = Неопределено;
	
	ИмяПользователяНаСервере = "";
	ПарольПользователяНаСервере = "";
	СпособАутентификацииНаСервере = "";
	ПеренаправлятьЗапросПоНовомуURI = Ложь;
	ВыполнятьАутентификациюПриПеренаправленииНаДругойХост = Ложь;
	ОбновлятьКуки(Истина);
	
	НаборШифров = Новый Массив;
	ЗаголовкиЗапроса = Новый Соответствие();
	ЗаголовкиОтвета = Новый Соответствие();
	ИменаЗаголовковЗапросаВНижнемРегистре = Новый Соответствие();
	
	ВременныеФайлы = Новый Соответствие();
	
	ЭмуляцияБраузера(Ложь);
	
КонецПроцедуры

// Отправляет HTTP запрос.
// 
// Параметры:
//  URL - Строка - URL
//  Метод - Строка - HTTP метод
//  Тело - Строка - Простой текст, Адрес двоичных данных во временном хранилище
//       - Структура
//       - Соответствие из КлючИЗначение
//       - ДвоичныеДанные
//       - Файл
//       - Неопределено
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция ОтправитьЗапрос(URL, Метод, Тело = Неопределено)

	КодСостояния = 0;
	ЗаголовкиОтвета.Очистить();
	
	УдалитьАртефакты();
	
	Команда = НоваяКоманда();
	
	Если РежимЭмуляцииБраузера Тогда
		ЭмуляцияChrome(Команда);
	КонецЕсли;
	
	ДобавитьURLВПараметрыКоманды(Команда, URL);
	ДобавитьМетодЗапросаВПараметрыКоманды(Команда, Метод);
	ДобавитьШифрыВПараметрыКоманды(Команда);
	ДобавитьЗаголовкиВПараметрыКоманды(Команда);
	ДобавитьФайлДампаЗаголовковВПараметрыКоманды(Команда);
	ДобавитьПроксиВПараметрыКоманды(Команда);
	ДобавитьДанныеАутентификацииВПараметрыКоманды(Команда);
	ДобавитьПеренаправлениеЗапросаВПараметрыКоманды(Команда);
	
	Если Метод = "POST" Тогда
		ДобавитьТелоЗапросаВПараметрыКоманды(Команда, Тело);
	КонецЕсли;

	ВыполнитьКоманду(Команда);
	
	ПрочитатьЗаголовкиОтвета();
	
	Если ОбновлятьКуки Тогда
		ОбновитьКуки();
	КонецЕсли;
	
	Возврат ЭтотОбъект();
	
КонецФункции

// Запускает внешнюю программу на исполнение с ожиданием завершения
//
// Параметры:
//  СтрокаКоманды  - Строка - командная строка для запуска программы.
//
// Возвращаемое значение:
//  Структура:
//    * КодВозврата - Число, Неопределено  - код возврата программы;
//    * ПотокОшибок - Строка - ошибки исполнения программы, направленные в поток stderr.
Функция ЗапуститьПрограмму(Знач СтрокаКоманды) 
	
	КодВозврата = Неопределено; // Число, Неопределено
		
	ИмяФайлаПотокаОшибок = НовоеИмяВременногоФайла("stderr.tmp");
	СтрокаКоманды = СтрокаКоманды + " 2>" + ОбернутьКавычками(ИмяФайлаПотокаОшибок);
	
	Если ЭтоWindows() Тогда
		Кодировка = КодировкаТекста.OEM;
			
		СтрокаКоманды = СтрШаблон("(chcp 866) && (%1)", СтрокаКоманды);
		СтрокаКоманды = "cmd /S /C " + ОбернутьКавычками(СтрокаКоманды);
	
		Если ИнформационнаяБазаФайловая() Тогда
			// В файловой информационной базе показывать окно консоли не следует и в серверном контексте.
			Попытка
				Оболочка = Новый COMОбъект("Wscript.Shell");
				КодВозврата = Оболочка.Run(СтрокаКоманды, 0, Истина); // Число, Неопределено
				Оболочка = Неопределено;
			Исключение
				Оболочка = Неопределено;
				
				ТекстОшибки = СтрШаблон("Не удалось запустить программу: 
				|%1", ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				ВызватьИсключение ТекстОшибки;
			КонецПопытки;	
		Иначе
			ЗапуститьПриложение(СтрокаКоманды,, Истина, КодВозврата);
		КонецЕсли;
		
	Иначе	
		Кодировка = КодировкаТекста.UTF8;
		ЗапуститьПриложение(СтрокаКоманды,, Истина, КодВозврата);
	КонецЕсли;

	Ошибки = ПрочитатьФайлЕслиСуществует(ИмяФайлаПотокаОшибок, Кодировка);
	УдалитьФайлЕслиСуществует(ИмяФайлаПотокаОшибок);
	
	Результат = Новый Структура;
	Результат.Вставить("КодВозврата", КодВозврата);
	Результат.Вставить("ПотокОшибок", Ошибки);
	
	Возврат Результат;
	
КонецФункции

Процедура ПрочитатьЗаголовкиОтвета()
	
	ЗаголовкиОтвета.Очистить();
	
	Если Не ЗначениеЗаполнено(ПутьКЗаголовкамОтвета) Тогда
		Возврат;	
	КонецЕсли;
	
	Текст = Новый ЧтениеТекста(ПутьКЗаголовкамОтвета, КодировкаТекста.UTF8);
	
	Строка = Текст.ПрочитатьСтроку();
	Пока Строка <> Неопределено Цикл
		
		Если СтрНайти(Строка, "HTTP/") = 1 Тогда
			Подстроки = СтрРазделить(Строка, " ");
			КодСостояния = Число(Подстроки[1]);
			ЗаголовкиОтвета.Очистить();
		КонецЕсли;
		
		ПозицияДвоеточия = СтрНайти(Строка, ":");
		Если ПозицияДвоеточия Тогда
			ИмяЗаголовка = НРег(Сред(Строка, 1, ПозицияДвоеточия - 1));
			Значение = СокрЛП(Сред(Строка, ПозицияДвоеточия + 1));
			
			Если ЗаголовкиОтвета.Получить(ИмяЗаголовка) = Неопределено Тогда
				ЗаголовкиОтвета.Вставить(ИмяЗаголовка, Значение);
			ИначеЕсли ТипЗнч(ЗаголовкиОтвета[ИмяЗаголовка]) = Тип("Массив") Тогда
				МассивЗначений = ЗаголовкиОтвета[ИмяЗаголовка]; // Массив из Строка
				МассивЗначений.Добавить(Значение);
			Иначе
				ПервоеЗначение = ЗаголовкиОтвета[ИмяЗаголовка]; // Строка
				МассивЗначений = Новый Массив; // Массив из Строка
				МассивЗначений.Добавить(ПервоеЗначение);
				МассивЗначений.Добавить(Значение);
				ЗаголовкиОтвета.Вставить(ИмяЗаголовка, МассивЗначений);
			КонецЕсли;

		КонецЕсли;
		
		Строка = Текст.ПрочитатьСтроку();	
	КонецЦикла;
	
	Текст.Закрыть();
	
	УдалитьФайлЕслиСуществует(ПутьКЗаголовкамОтвета);
	
КонецПроцедуры

// Парсит заголовки из текста. 
// Текст должен содежрать пары ключ-значение. Значение от ключа должно быть разделено двоеточием. 
// Пары должны быть разделены символом переноса.
// 
// Параметры:
//  Текст - Строка - Текст
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение
Функция ЗаголовкиИзТекста(Текст)
	
	Заголовки = Новый Соответствие();
	
	Для НомерСтроки = 1 По СтрЧислоСтрок(Текст) Цикл
		
		Строка = СтрПолучитьСтроку(Текст, НомерСтроки);
		ПозицияДвоеточия = СтрНайти(Строка, ":");
		Если ПозицияДвоеточия Тогда
			Имя = СокрЛП(Сред(Строка, 1, ПозицияДвоеточия - 1));
			Значение = СокрЛП(Сред(Строка, ПозицияДвоеточия + 1));
			Заголовки.Вставить(Имя, Значение);
		КонецЕсли;
				
	КонецЦикла;
	
	Возврат Заголовки;
	
КонецФункции

Процедура ОбновитьИменаЗаголовковВВерхнемРегистре()
	
	ИменаЗаголовковЗапросаВНижнемРегистре.Очистить();
	
	Для Каждого КлючИЗначение Из ЗаголовкиЗапроса Цикл
		ИмяЗаголовка = КлючИЗначение.Ключ; // Строка
		ИменаЗаголовковЗапросаВНижнемРегистре.Вставить(НРег(ИмяЗаголовка), ИмяЗаголовка);
	КонецЦикла;
	
КонецПроцедуры

// Преобразует структуру в тело запроса.
// 
// Параметры:
//  Тело	- Структура
//  		- Соответствие из КлючИЗначение
// 
// Возвращаемое значение:
//  Строка
Функция СтруктураВТелоЗапроса(Тело)

	ТелоЗапроса = "";

	Для Каждого КлючИЗначение Из Тело Цикл	
		Значение = КодироватьСтроку(XMLСтрока(КлючИЗначение.Значение), СпособКодированияСтроки.КодировкаURL);

		ТелоЗапроса = ТелоЗапроса 
			+ ?(ТелоЗапроса = "", "", "&")
			+ КлючИЗначение.Ключ + "=" + Значение;	
	КонецЦикла;	
	
	Возврат ТелоЗапроса;
	
КонецФункции

Функция СпособАутентификацииНаСервереBasic()
	Возврат "basic";	
КонецФункции

Функция СпособАутентификацииНаСервереDigest()
	Возврат "digest";	
КонецФункции

// Обернуть кавычками строку.
// 
// Параметры:
//  Строка - Строка - Строка
// 
// Возвращаемое значение:
//  Строка - Обернуть кавычками
Функция ОбернутьКавычками(Строка)
	Возврат """" + Строка + """";
КонецФункции

// Этот объект.
// 
// Возвращаемое значение:
//  ОбработкаОбъект.cURL, ВнешняяОбработка.cURL - Этот объект
//@skip-check doc-comment-type
Функция ЭтотОбъект()
	Возврат ЭтотОбъект;
КонецФункции

#Область РаботаСФайлами

// Возвращает имя временного файла.
// 
// Параметры:
//  Расширение - Строка - Расширение файла
// 
// Возвращаемое значение:
//  Строка - имя временного файла
Функция НовоеИмяВременногоФайла(Расширение = "")
	//@skip-check missing-temporary-file-deletion
	Имя = ПолучитьИмяВременногоФайла(Расширение);
	ВременныеФайлы.Вставить(Имя);
	Возврат Имя;
КонецФункции

// Удаляет артефакты выполнения запроса.
Процедура УдалитьАртефакты()
	
	Для Каждого Строка Из ВременныеФайлы Цикл
		Путь = Строка.Ключ; // Строка
		УдалитьФайлЕслиСуществует(Путь);
	КонецЦикла;
	
КонецПроцедуры

// Удаляет файл, если существует.
// 
// Параметры:
//  Путь - Строка - Путь к файлу
Процедура УдалитьФайлЕслиСуществует(Путь)
	
	Если Не ЗначениеЗаполнено(Путь) Тогда
		Возврат;
	КонецЕсли;
	
	Файл = Новый Файл(Путь);
	Если Файл.Существует() Тогда
		УдалитьФайлы(Путь);	
	КонецЕсли;
	
	ВременныеФайлы.Удалить(Путь);
	
	Путь = "";
	
КонецПроцедуры

// Удаляет файл если пустой.
// 
// Параметры:
//  Путь - Строка - Путь к файлу
Процедура УдалитьФайлЕслиПустой(Путь)
	
	Если Не ЗначениеЗаполнено(Путь) Тогда
		Возврат;
	КонецЕсли;
		
	Файл = Новый Файл(Путь);
	Если Файл.Существует() Тогда
		Если Файл.Размер() = 0 Тогда
			УдалитьФайлЕслиСуществует(Путь);	
		Иначе
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Путь = "";

КонецПроцедуры

// Возвращает содержимое файла.
// 
// Параметры:
//  Путь - Строка - Путь
//  Кодировка - КодировкаТекста - Кодировка
// 
// Возвращаемое значение:
//  Строка - Содержимое файла
Функция ПрочитатьФайлЕслиСуществует(Путь, Кодировка)
	
	Результат = "";
	ФайлИнфо = Новый Файл(Путь);
	
	Если ФайлИнфо.Существует() Тогда 
		
		ЧтениеПотокаОшибок = Новый ЧтениеТекста(Путь, Кодировка);
		Результат = ЧтениеПотокаОшибок.Прочитать();
		ЧтениеПотокаОшибок.Закрыть();
		
	КонецЕсли;
	
	Если Результат = Неопределено Тогда 
		Результат = "";
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Прочитать файл JSON.
// 
// Параметры:
//  ПутьКФайлу - Строка - Путь к файлу
// 
// Возвращаемое значение:
//  Произвольный
Функция ПрочитатьФайлJSON(ПутьКФайлу)
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.ОткрытьФайл(ПутьКФайлу);
	
	Результат = ПрочитатьJSON(ЧтениеJSON, Истина);

	ЧтениеJSON.Закрыть();
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ПодготовкаКоманды
	
Функция НоваяКоманда()

	Путь = ПутьКИсполняемомуФайлу;
	Если Не ЗначениеЗаполнено(ПутьКИсполняемомуФайлу) Тогда
		Путь = "curl";
	КонецЕсли;
		
	Возврат ОбернутьКавычками(Путь);
	
КонецФункции

Процедура ДобавитьПараметрКоманды(Команда, Имя, Значение = "", Разделитель = " ")
	Команда = Команда + " " + Имя + ?(ЗначениеЗаполнено(Значение), Разделитель + Значение, "");
КонецПроцедуры

// Добавляет URL в параметры команды.
// 
// Параметры:
//  Команда - Строка - Команда
//  URL - Строка - URL
Процедура ДобавитьURLВПараметрыКоманды(Команда, URL)
	ДобавитьПараметрКоманды(Команда, "--url", ОбернутьКавычками(URL));	
КонецПроцедуры

// Добавляет метод запроса в параметры команды.
// 
// Параметры:
//  Команда - Строка - Команда
//  Метод - Строка - HTTP метод
Процедура ДобавитьМетодЗапросаВПараметрыКоманды(Команда, Метод)
	ДобавитьПараметрКоманды(Команда, "-X", Метод);
КонецПроцедуры

// Добавляет заголовки в параметры команды.
// 
// Параметры:
//  Команда - Строка - Команда
Процедура ДобавитьЗаголовкиВПараметрыКоманды(Команда)
	
	Если ЗаголовкиЗапроса = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ЗаголовкиТекст = "";
	Для Каждого КлючИЗначение Из ЗаголовкиЗапроса Цикл
		ЗаголовкиТекст = ЗаголовкиТекст 
			+ СтрШаблон("%1: %2", КлючИЗначение.Ключ, КлючИЗначение.Значение)
			+ Символы.ПС;	
	КонецЦикла;
	
	ПутьКЗаголовкамЗапроса = НовоеИмяВременногоФайла();
	
	ТекстовыйДокумент = Новый ТекстовыйДокумент();
	ТекстовыйДокумент.УстановитьТекст(ЗаголовкиТекст);
	ТекстовыйДокумент.Записать(ПутьКЗаголовкамЗапроса, "CESU-8");
	
	ДобавитьПараметрКоманды(Команда, "--header", "@" + ПутьКЗаголовкамЗапроса);
	
КонецПроцедуры

// Добавляет шифры в параметры команды.
// 
// Параметры:
//  Команда - Строка - Команда
Процедура ДобавитьШифрыВПараметрыКоманды(Команда)
	
	Если Не НаборШифров.Количество() Тогда
		Возврат;
	КонецЕсли;
		
	Шифры = СтрСоединить(НаборШифров, ",");
	ДобавитьПараметрКоманды(Команда, "--ciphers", Шифры);
	
КонецПроцедуры

// Добавляет тело запроса в параметры команды.
// 
// Параметры:
//  Команда - Строка - Команда
//  Тело - Строка - Простой текст, Адрес двоичных данных во временном хранилище
//       - Структура
//       - Соответствие из КлючИЗначение
//       - ДвоичныеДанные
//       - Файл
//       - Неопределено
Процедура ДобавитьТелоЗапросаВПараметрыКоманды(Команда, Тело)
	
	Если Тело = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(Тело) = Тип("Строка") И ЭтоАдресВременногоХранилища(Тело) Тогда
		Данные = ПолучитьИзВременногоХранилища(Тело);	
	ИначеЕсли ТипЗнч(Тело) = Тип("Структура") Или ТипЗнч(Тело) = Тип("Соответствие") Тогда		
		Данные = СтруктураВТелоЗапроса(Тело);	
	Иначе
		Данные = Тело;
	КонецЕсли;
	
	Если ТипЗнч(Данные) = Тип("ДвоичныеДанные") Тогда
		
		ПутьКТелуЗапроса = НовоеИмяВременногоФайла();
		Данные.Записать(ПутьКТелуЗапроса);
		
		ДобавитьПараметрКоманды(Команда, "--data-binary", "@" + ПутьКТелуЗапроса);
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Файл") Тогда
		
		Если Данные.Существует() Тогда
			ДобавитьПараметрКоманды(Команда, "--data-binary", "@" + Данные.ПолноеИмя);
		Иначе
			ВызватьИсключение СтрШаблон("Файл '%1' не существует", Данные.ПолноеИмя);
		КонецЕсли;
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Строка") Тогда
		
		ДобавитьПараметрКоманды(Команда, "--data-raw", ОбернутьКавычками(Данные));
		
	Иначе
		
		ВызватьИсключение СтрШаблон("Тип %1 не поддерживается в качестве тела запроса", ТипЗнч(Тело));
		
	КонецЕсли;
					
КонецПроцедуры

// Добавляет файл дампа заголовков в параметры команды.
// 
// Параметры:
//  Команда - Строка - Команда
Процедура ДобавитьФайлДампаЗаголовковВПараметрыКоманды(Команда)
	
	ПутьКЗаголовкамОтвета = НовоеИмяВременногоФайла();
	ДобавитьПараметрКоманды(Команда, "--dump-header", ПутьКЗаголовкамОтвета);
	
КонецПроцедуры

Процедура ДобавитьПроксиВПараметрыКоманды(Команда)
	
	Если ИнтернетПрокси = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Протокол = "http";
	Если ИнтернетПрокси.Порт() = 443 Тогда
		Протокол = "https";	
	КонецЕсли;
	
	ДобавитьПараметрКоманды(Команда, "--proxy", СтрШаблон("%1://%2", Протокол, ИнтернетПрокси.Сервер()));
	
	Если ЗначениеЗаполнено(ИнтернетПрокси.Пользователь) Тогда
		ДобавитьПараметрКоманды(Команда, "--proxy-user", СтрШаблон("%1:%2", ИнтернетПрокси.Пользователь, ИнтернетПрокси.Пароль));	
	КонецЕсли;
	
КонецПроцедуры

// Добавляет данные аутентификации на сервере в параметры команды.
// 
// Параметры:
//  Команда - Строка - Команда
Процедура ДобавитьДанныеАутентификацииВПараметрыКоманды(Команда)
	
	Если Не ЗначениеЗаполнено(ИмяПользователяНаСервере) Тогда
		Возврат;
	КонецЕсли;
	
	ДобавитьПараметрКоманды(Команда, "--user", СтрШаблон("%1:%2", ИмяПользователяНаСервере, ПарольПользователяНаСервере));
 
 	Если СпособАутентификацииНаСервере = СпособАутентификацииНаСервереDigest() Тогда
 		ДобавитьПараметрКоманды(Команда, "--digest");
 	Иначе
 		ДобавитьПараметрКоманды(Команда, "--basic");
 	КонецЕсли;
 	
КонецПроцедуры

// Добавляет перенаправление запроса в параметры команды.
// 
// Параметры:
//  Команда - Строка - Команда
Процедура ДобавитьПеренаправлениеЗапросаВПараметрыКоманды(Команда)
	
	Если Не ПеренаправлятьЗапросПоНовомуURI Тогда
		Возврат;
	КонецЕсли;
	
	Если ВыполнятьАутентификациюПриПеренаправленииНаДругойХост Тогда
		ДобавитьПараметрКоманды(Команда, "--location-trusted");	
	Иначе
		ДобавитьПараметрКоманды(Команда, "--location");	
	КонецЕсли;
 	
КонецПроцедуры

Процедура ВыполнитьКоманду(Команда)
	
	ПутьКРезультату = НовоеИмяВременногоФайла();
	
	ДобавитьПараметрКоманды(Команда, "--silent");
	ДобавитьПараметрКоманды(Команда, "--output", ОбернутьКавычками(ПутьКРезультату));
	
	Попытка
		РезультатЗапуска = ЗапуститьПрограмму(Команда);
			
		Если Не ПустаяСтрока(РезультатЗапуска.ПотокОшибок) Тогда
			ВызватьИсключение РезультатЗапуска.ПотокОшибок;		
		КонецЕсли;		
	Исключение
		УдалитьАртефакты();
		
		ТекстОшибки = СтрШаблон("Не удалось выполнить команду curl: 
		|%1", ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
				
	УдалитьФайлЕслиСуществует(ПутьКЗаголовкамЗапроса);
	УдалитьФайлЕслиСуществует(ПутьКТелуЗапроса);
	УдалитьФайлЕслиПустой(ПутьКРезультату);
	
КонецПроцедуры

#КонецОбласти

#Область Куки

// Десериализовывает значение заголовка ответа Set-Cookie.
// 
// Параметры:
//  Строка - Строка - Значение заголовка Set-Cookie
// 
// Возвращаемое значение:
//  см. НоваяЗаписьКуки
Функция ДесериализоватьSetCookie(Строка)
	
	Если Не ЗначениеЗаполнено(Строка) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивСтрокАтрибутов = СтрРазделить(Строка, ";");
	
	ЗаписьКуки = НоваяЗаписьКуки();
	
	Для Каждого СтрокаАтрибута Из МассивСтрокАтрибутов Цикл
		ПозицияРавенства = СтрНайти(СтрокаАтрибута, "=");
		
		ЗначениеАтрибута = ""; // Строка, Булево
		Если ПозицияРавенства Тогда
			ИмяАтрибута = СокрЛП(Сред(СтрокаАтрибута, 1, ПозицияРавенства - 1));	
			ЗначениеАтрибута = СокрЛП(Сред(СтрокаАтрибута, ПозицияРавенства + 1));
		Иначе
			ИмяАтрибута = СокрЛП(СтрокаАтрибута);
			ЗначениеАтрибута = Истина;
		КонецЕсли;
			
		Если ЭтоАтрибутКуки(ИмяАтрибута) Тогда
			ЗаписьКуки[НормализованноеИмяАтрибутаКуки(ИмяАтрибута)] = ЗначениеАтрибута;
		ИначеЕсли Не ЗначениеЗаполнено(ЗаписьКуки["Name"]) Тогда
			ЗаписьКуки["Name"] = ИмяАтрибута;
			ЗаписьКуки["Value"] = ЗначениеАтрибута;
		КонецЕсли;
	КонецЦикла;

	Возврат ЗаписьКуки;

КонецФункции

// Новая запись куки.
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение - Запись куки
Функция НоваяЗаписьКуки()
	Запись = Новый Соответствие(); // Соответствие из КлючИЗначение
	Запись.Вставить("Name");
	Запись.Вставить("Value");
	
	Для Каждого КлючЗначение Из АтрибутыКуки() Цикл
		Запись.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
	КонецЦикла;	
	
	Возврат Запись;
КонецФункции

Функция ЭтоАтрибутКуки(Знач Имя)
	
	Имя = НРег(Имя);

	Для Каждого КлючЗначение Из АтрибутыКуки() Цикл
		Если Имя = НРег(КлючЗначение.Ключ) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция АтрибутыКуки()
	Результат = Новый Соответствие(); // Соответствие из КлючИЗначение
	Результат.Вставить("Domain");
	Результат.Вставить("Expires");	
	Результат.Вставить("Path");
	Результат.Вставить("SameSite");
	Результат.Вставить("Secure", Ложь);
	Результат.Вставить("HttpOnly", Ложь);
	Результат.Вставить("Max-Age");	
	Результат.Вставить("Partitioned", Ложь);
	Результат.Вставить("Priority");
	Возврат Результат;
КонецФункции

// Нормализованное имя атрибута куки.
// 
// Параметры:
//  Имя - Строка - Имя
// 
// Возвращаемое значение:
//  Строка - Нормализованное имя атрибута куки
Функция НормализованноеИмяАтрибутаКуки(Знач Имя)

	Имя = НРег(Имя);
	
	Для Каждого КлючЗначение Из АтрибутыКуки() Цикл
		Если Имя = НРег(КлючЗначение.Ключ) Тогда
			Возврат КлючЗначение.Ключ;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Имя;
	
КонецФункции

#КонецОбласти

#Область Эмуляция

// Эмуляция chrome.
// 
// Параметры:
//  Команда - Строка - Команда
Процедура ЭмуляцияChrome(Команда)
	
	УстановитьЗаголовкиChrome();
	ДобавитьШифрыChrome();
	
	Если Не ПеренаправлятьЗапросПоНовомуURI Тогда
		ПеренаправлятьЗапрос();
	КонецЕсли;
	
	ДобавитьПараметрКоманды(Команда, "--http2");
	ДобавитьПараметрКоманды(Команда, "--tlsv1.2");
	ДобавитьПараметрКоманды(Команда, "--compressed");
	
КонецПроцедуры

Функция УстановитьЗаголовкиChrome()
	Заголовки = ПолучитьМакет("ChromeHeaders").ПолучитьТекст(); 
	УстановитьЗаголовки(Заголовки);
	Возврат ЭтотОбъект();
КонецФункции

// Добавляет шифры chrome в набор.
// 
// Возвращаемое значение:
//  см. ЭтотОбъект
Функция ДобавитьШифрыChrome()
	НаборШифров.Очистить();
	Возврат ДобавитьШифры("TLS_AES_128_GCM_SHA256,TLS_AES_256_GCM_SHA384,TLS_CHACHA20_POLY1305_SHA256,ECDHE-ECDSA-AES128-GCM-SHA256,ECDHE-RSA-AES128-GCM-SHA256,ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384,ECDHE-ECDSA-CHACHA20-POLY1305,ECDHE-RSA-CHACHA20-POLY1305,ECDHE-RSA-AES128-SHA,ECDHE-RSA-AES256-SHA,AES128-GCM-SHA256,AES256-GCM-SHA384,AES128-SHA,AES256-SHA");
КонецФункции

#КонецОбласти

#Область ОбщегоНазначения

// Дополняет массив МассивПриемник значениями из массива МассивИсточник.
//
// Параметры:
//  МассивПриемник - Массив из Произвольный - массив, в который необходимо добавить значения.
//  МассивИсточник - Массив из Произвольный - массив значений для заполнения.
//  ТолькоУникальныеЗначения - Булево - если истина, то в массив будут включены только уникальные значения.
//
Процедура ДополнитьМассив(МассивПриемник, МассивИсточник, ТолькоУникальныеЗначения = Ложь)
	
	Если ТолькоУникальныеЗначения Тогда
		
		УникальныеЗначения = Новый Соответствие;
		
		Для Каждого Значение Из МассивПриемник Цикл
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЦикла;
		
		Для Каждого Значение Из МассивИсточник Цикл
			Если УникальныеЗначения[Значение] = Неопределено Тогда
				МассивПриемник.Добавить(Значение);
				УникальныеЗначения.Вставить(Значение, Истина);
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		Для Каждого Значение Из МассивИсточник Цикл
			МассивПриемник.Добавить(Значение);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Создает полную копию структуры, соответствия, массива, списка или таблицы значений, рекурсивно, 
// с учетом типов дочерних элементов. При этом содержимое значений объектных типов 
// (СправочникОбъект, ДокументОбъект и т.п.) не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  Источник - Структура
//           - Соответствие из КлючИЗначение
//           - Массив из Произвольный
//           - СписокЗначений из Произвольный
//           - ТаблицаЗначений - объект, который необходимо скопировать.
//
// Возвращаемое значение:
//  - Структура
//  - Соответствие из КлючИЗначение
//  - Массив из Произвольный
//  - СписокЗначений из Произвольный
//  - ТаблицаЗначений - копия объекта, переданного в параметре Источник.
//
Функция СкопироватьРекурсивно(Источник)
	
	Перем Приемник; // Структура, Соответствие, Массив, СписокЗначений, ТаблицаЗначений
	
	ТипИсточника = ТипЗнч(Источник);
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	Если ТипИсточника = Тип("ТаблицаЗначений") Тогда
		Возврат Источник.Скопировать();
	КонецЕсли;
#КонецЕсли	
	Если ТипИсточника = Тип("Структура") Тогда
		Приемник = СкопироватьСтруктуру(Источник);
	ИначеЕсли ТипИсточника = Тип("Соответствие") Тогда
		//@skip-check statement-type-change
		Приемник = СкопироватьСоответствие(Источник);
	ИначеЕсли ТипИсточника = Тип("Массив") Тогда
		//@skip-check statement-type-change
		Приемник = СкопироватьМассив(Источник);
	ИначеЕсли ТипИсточника = Тип("СписокЗначений") Тогда
		//@skip-check statement-type-change
		Приемник = СкопироватьСписокЗначений(Источник);
	Иначе
		Приемник = Источник;
	КонецЕсли;
	
	Возврат Приемник;
	
КонецФункции

// Создает копию значения типа Структура, рекурсивно, с учетом типов значений свойств. 
// Если свойства структуры содержат значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  СтруктураИсточник - Структура - копируемая структура.
// 
// Возвращаемое значение:
//  Структура - копия исходной структуры.
//
Функция СкопироватьСтруктуру(СтруктураИсточник)
	
	СтруктураРезультат = Новый Структура;
	
	Для Каждого КлючИЗначение Из СтруктураИсточник Цикл
		Значение = КлючИЗначение.Значение; // Структура, Соответствие, Массив, СписокЗначений, ТаблицаЗначений
		СтруктураРезультат.Вставить(КлючИЗначение.Ключ, СкопироватьРекурсивно(Значение));
	КонецЦикла;
	
	Возврат СтруктураРезультат;
	
КонецФункции

// Создает копию значения типа Соответствие, рекурсивно, с учетом типов значений.
// Если значения соответствия содержат значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  СоответствиеИсточник - Соответствие из КлючИЗначение - соответствие, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение - копия исходного соответствия.
//
Функция СкопироватьСоответствие(СоответствиеИсточник)
	
	СоответствиеРезультат = Новый Соответствие;
	
	Для Каждого КлючИЗначение Из СоответствиеИсточник Цикл
		Значение = КлючИЗначение.Значение; // Структура, Соответствие, Массив, СписокЗначений, ТаблицаЗначений
		СоответствиеРезультат.Вставить(КлючИЗначение.Ключ, СкопироватьРекурсивно(Значение));
	КонецЦикла;
	
	Возврат СоответствиеРезультат;

КонецФункции

// Создает копию значения типа Массив, рекурсивно, с учетом типов значений элементов массива.
// Если элементы массива содержат значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  МассивИсточник - Массив из Произвольный - массив, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  Массив из Произвольный - копия исходного массива.
//
Функция СкопироватьМассив(МассивИсточник) Экспорт
	
	МассивРезультат = Новый Массив; // Массив из Произвольный
	
	Для Каждого Элемент Из МассивИсточник Цикл
		//@skip-check typed-value-adding-to-untyped-collection
		//@skip-check invocation-parameter-type-intersect
		МассивРезультат.Добавить(СкопироватьРекурсивно(Элемент));
	КонецЦикла;
	
	Возврат МассивРезультат;
	
КонецФункции

// Создает копию значения типа СписокЗначений, рекурсивно, с учетом типов его значений.
// Если в списке значений есть значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  СписокИсточник - СписокЗначений из Произвольный - список значений, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  СписокЗначений из Произвольный - копия исходного списка значений.
//
Функция СкопироватьСписокЗначений(СписокИсточник) Экспорт
	
	СписокРезультат = Новый СписокЗначений;
	
	Для Каждого ЭлементСписка Из СписокИсточник Цикл
		//@skip-check typed-value-adding-to-untyped-collection
		//@skip-check invocation-parameter-type-intersect
		СписокРезультат.Добавить(
			СкопироватьРекурсивно(ЭлементСписка.Значение), 
			ЭлементСписка.Представление, 
			ЭлементСписка.Пометка, 
			ЭлементСписка.Картинка);
	КонецЦикла;
	
	Возврат СписокРезультат;
	
КонецФункции

Функция ЭтоWindows() Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Возврат СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86 
		Или СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64;
	
КонецФункции

Функция ЭтоLinux() Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Возврат СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86 
		Или СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86_64;
	
КонецФункции

// Определяет режим эксплуатации информационной базы файловый (Истина) или серверный (Ложь).
// При проверке используется СтрокаСоединенияИнформационнойБазы, которую можно указать явно.
//
// Возвращаемое значение:
//  Булево - Истина, если файловая.
//
Функция ИнформационнаяБазаФайловая()
	СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	Возврат СтрНайти(ВРег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область Инициализация

УстановитьНачальныеНастройки();

#КонецОбласти

#КонецЕсли